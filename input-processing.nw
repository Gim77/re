% -*- mode: NoWeb; noweb-code-mode: c-mode *-*
% input-processing.nw
@
This chapter describes how the input file are converted into the
observations files that are used for model development.

Four sets of input files are used.
\begin{itemize}
\item Deeds. A deed records the transfer of property or rights on the
  property from one party to another. The input data contains 8 deeds
  files with names [[CAC06037F?.txt]]. These are tab-separated files
  with a header record preceeding data records. CoreLogic claims that
  all deeds for Los Angeles County (that's what the 06037 means) for
  the years 1975 - 2009 are in the files. A deed represents, among
  other things, the sale of a property.  This project examines only
  the deeds for single family properties that were sales transactions
  at an arms-length price for the full value of one parcel.
\item Taxroll. A taxroll record records information used by the tax
  assessor to generate property tax bills. The input data contains 8
  deeds files with names [[CAC06037F?.txt]]. The
  taxroll file is for the year 2008. It contains descriptions of the
  properties called parcels. For some parcels, there are no deeds; for
  others, many deeds.
\item Census. File [[census.csv]] contains
  data on the census tracts in 1999. Each parcel belongs to exactly one census
  tract. Data on the census tract are from the US govertment census
  carried out every 10 years. Three features are developed from the
  census data: average commute time, average income, and fraction of
  residences that are occupied by their owners. The census data
  augment the features that are in the taxroll files.
\item Geocoding. File [[geocoing.tsv]] contains the latitude
  and longitude of each parcel. These data come from a geomapping
  service and were purchased for the project. The geocoding data also
  augment the features that are in the taxroll file.
\end{itemize}

The output is table [[observations]] in the data base. It contains the
join of the input files. Many records are dropped as they are not
relevant to single family houses. Many columns of data are retained,
but many are dropped, as being of low potential value as features. The
details of which records and which columns are dropped is given in the
narrative below.
TODO: revise
Two output observations sets are generated by joining the four sets of
input files using the parcel identifier field APN (tax accessor's
parcel number).


The remained of this
chapter is organized around the processing and joining selected
records and columns from the files.
\begin{itemize}
\item Section 1 discusses importing the deeds into a SQLite3 database,
  the issues encountered, and how the issues were resolved.
\item Section 2 is a similar discussion for the taxroll.
\item Section 3 discusses importing the census files.
\item Section 4 discusses importing the geocoding file.
\item Section 5 describes how the four imported files were joined to
  create the transaction sets.
\item Section 6 describes how the code fields were converted to 1-of-K
  encoded fields.
\end{itemize}

This document was generated from noweb and hence contains the code
used to carry out all the processing steps. 


@\section{Importing the Deeds}
The first order of business is to create the database. SQLite3 stores
all the table in one file on disk. Several iterations were required
ending at version 5. The [[sqlite3]] command creates the data base if
it does not exist.

Set sqlite3 command line options to stop processing if an error occurs
([[-bail]]).

<<start-sqlite>>=
sqlite3 -bail ../data/v5/outputs/db.sqlite3
@ The database is created by simply starting SQLite3.

<<db-create-database.sh>>= 
rm ../data/v5/outputs/db.sqlite3
<<start-sqlite>> < db-create-database.sql

@ Some sort of input is needed
<<db-create-database.sql>>=
.echo on
.tables

@ The [[deeds_all]] table will hold all of the data from the deeds, as
this makes loading the table relatively easy. Later, relevant subsets
of the deeds are created.

Q: Is this true with these data? Try using apn unformatted as the
primary key.

A logical primary key for table [[deeds_all]] is the APN, the accessor
parcel number, a ten-digit number. It's role is to be a unique
identifier for the parcel. Unfortunately, it is not always present and
when present, is not always correctly coded.

Fortunately, the APN is present in two fields: [[apn_unformatted]]
contains the unformated number and [[apn_formatted]] inserts hyphens
so that the number is in the form ``9999-999-999''. 

After the deeds files are imported into table [[deeds_all]], a program
will be run that creates a new apn field [[apn_recoded]] that contains
the ``best'' of the two versions of the in-file APN fields. This
approach allows many more records to be used than just always using
one of the APN fields. Details are given below. The primary key of the
deeds table is just an integer generated sequentially by SQLite3.

The SQL command to create the table is below. In case the script is
run more than once (typical during development), delete the table and
re-create it. This command is found by combining the documentation for
CoreLogic (CoreLogic calls the record layout ``1080'') with the header
in the supplied files, because not all fields that are documented are
actually present. Fields that are documented as present and are
missing are commented out.

The best primary key to use for the data might seem to be the
concatenation of the [[apn_unformatted]] and [[sale_date]]. However, a
property can sell twice on the same date and there are possibly errors
in the two candidate key fields. So no explicit primary key is
designated. 

<<create table deeds all>>=
DROP TABLE IF EXISTS deeds_all;
CREATE TABLE deeds_all (
  /* primary key is rowid, generated by SQLite3 */

  /* key information */
  fips_code                         TEXT,
  fips_sub_code                     TEXT,
  municipality_code                 TEXT,
  apn_unformatted                   TEXT, 
  apn_formatted                     TEXT,
  apn_sequence_number               TEXT,
  --original_apn                    TEXT,
  --account_number                  TEXT,

  /* name and address */
  --owner_corporate_indicator_flag  TEXT,
  --owner_buyer_last_name           TEXT,
  --owner_buyer_first_name          TEXT,
  --owner_etal_indicator_code       TEXT /* code table ETAL */,
  --owner_co_name                   TEXT,
  --owner_ownership_rights_code     TEXT /* code table OWNSH */,
  --owner_relationship_type_coe     TEXT /* code table RELAT */,

  /* mailing address */  
  mail_house_number_prefix          TEXT,
  mail_house_number                 TEXT,
  mail_house_number_suffix          TEXT,
  mail_street_direction             TEXT,
  mail_street_name                  TEXT,
  mail_mode                         TEXT,
  mail_quadrant                     TEXT,
  mail_apartment_unit_number        TEXT,
  mail_city                         TEXT,
  mail_state                        TEXT,
  mail_zip_code                     TEXT,
  mail_carrier_route                TEXT,
  mail_match_code                   TEXT /* code table MATCH */,

  /* property address */
  property_address_indicator_code   TEXT /* code table ADDRIND */,
  property_house_number_prefix      TEXT,
  property_house_number             TEXT,
  property_house_number_suffix      TEXT,
  property_street_name              TEXT,
  property_mode                     TEXT,
  property_direction                TEXT,
  property_quadrant                 TEXT,
  property_apartment_unit_number    TEXT,
  property_city                     TEXT,
  property_state                    TEXT,
  property_zip_code                 TEXT,
  property_carrier_route            TEXT,

  /* sale information */
  batch_id                          TEXT,
  batch_seq                         TEXT,
  document_year                     TEXT,
  --seller_name                     TEXT,
  sale_amount                       INTEGER,
  mortgage_amount                   INTEGER,
  sale_date                         TEXT,
  recording_date                    TEXT,
  document_type_code                TEXT /* code table DEEDC */,
  transaction_type_code             TEXT /* code table TRNTP */,
  --document_number                 TEXT,
  --book_page                       TEXT,
  --lender_last_name                TEXT,
  --lender_first_name               TEXT,
  --lender_address                  TEXT,
  --lender_city                     TEXT,
  --lender_state                    TEXT,
  --lender_zip_code                 TEXT,
  --lender_company_code             TEXT,
  sale_code                         TEXT /* code table SCODE */,
  --owner_buyer_middle_initial      TEXT,
  --filler01                        TEXT,
  multi_apn_flag_code               TEXT /* code table SLMLT */,
  multi_apn_count                   TEXT,
  title_company_code                TEXT,
  residential_model_indicator_flag  TEXT,
  mortgage_date                     TEXT,
  mortgage_loan_type_code           TEXT /* code table MTGTP */,
  mortgage_deed_type_code           TEXT /* code table DOCTY */,
  mortgage_term_code                TEXT /* code table MTGTC */,
  mortgage_term                     TEXT,
  mortgage_due_date                 TEXT,
  mortgage_assumption_amount        INTEGER,
  second_mortgate_amount            INTEGER,
  second_mortgage_loan_type_code    TEXT /* code table MTGTP */,
  second_mortgage_deed_type_code    TEXT /* code table DOCTY */,
  --prior_doc_year                  TEXT, /* no prior field is populated */
  --prior_doc_number                TEXT,
  --prior_book_page                 TEXT,
  --prior_document_type_code        TEXT /* code table DEEDC */,
  prior_recording_date              TEXT,
  prior_sales_date                  TEXT,
  prior_sales_amount                INTEGER,
  prior_sales_code                  TEXT /* code table SCODE */,
  prior_sales_transaction_type_code TEXT /* code table TRNTP */,
  prior_multi_apn_flag_code         TEXT /* code table SLMLT */,
  prior_multi_apn_count             TEXT,
  prior_mortgage_amount             INTEGER,
  prior_mortgage_deed_type_code     TEXT /* code table DOCTY */,
  absentee_indicator_code           TEXT /* code table ABSIND */,
  property_indicator_code           TEXT /* code table PROPN */,
  buiding_square_feet               INTEGER,
  partial_interest_indicator_flag   TEXT,
  ownership_transfer_percentage     TEXT,
  universal_land_use_code           TEXT /* code tabel LUSEI */,
  pri_cat_code                      TEXT /* code table PRICATCODE */,
  mortgage_interest_rate_type_code  TEXT /* code table INTRT */,
  --title_company_name              TEXT,
  seller_carry_back_flag            TEXT,
  private_party_lender_flag         TEXT,
  construction_loan_flag            TEXT,
  resale_new_construction_code      TEXT /* code table RESNEW */,
  inter_family_flag                 TEXT,
  cash_mortgage_purchase_code       TEXT /* code tabel CASHMTGTP */,
  foreclosure_code                  TEXT /* code table FORECLOSURE */,
  refi_flag_code                    TEXT /* code table REFIFLAG */,
  equity_flag_code                  TEXT /* code table EQUITY */,
  census_tract                      TEXT,
  census_block_group                TEXT,
  census_block                      TEXT,
  census_block_suffix               TEXT,
  --latitude                        FLOAT,
  --longitude                       FLOAT,
  record_type_code                  TEXT /* code table RECTYPE */
  --filler02                        TEXT
);
@ To populate [[deeds_all]], create the table, then read the 8 deeds
files and insert their content into the table. The input files arrive
in compressed form and need to be decompressed before using them. They
each have a header record that must be dropped, or it will end up in
the database.

I delete the decompressed files after the import, as they are no
longer needed.

<<decompress deeds files>>=
pushd ../data/raw/from-laufer-2010-05-11/deeds
gzip -d -f -c CAC06037F1.txt.gz | tail -n +2 > /tmp/CAC06037F1.txt
gzip -d -f -c CAC06037F2.txt.gz | tail -n +2 > /tmp/CAC06037F2.txt
gzip -d -f -c CAC06037F3.txt.gz | tail -n +2 > /tmp/CAC06037F3.txt
gzip -d -f -c CAC06037F4.txt.gz | tail -n +2 > /tmp/CAC06037F4.txt
gzip -d -f -c CAC06037F5.txt.gz | tail -n +2 > /tmp/CAC06037F5.txt
gzip -d -f -c CAC06037F6.txt.gz | tail -n +2 > /tmp/CAC06037F6.txt
gzip -d -f -c CAC06037F7.txt.gz | tail -n +2 > /tmp/CAC06037F7.txt
gzip -d -f -c CAC06037F8.txt.gz | tail -n +2 > /tmp/CAC06037F8.txt
popd
@
<<delete decompressed deeds files>>=
rm /tmp/CAC06037F1.txt
rm /tmp/CAC06037F2.txt
rm /tmp/CAC06037F3.txt
rm /tmp/CAC06037F4.txt
rm /tmp/CAC06037F5.txt
rm /tmp/CAC06037F6.txt
rm /tmp/CAC06037F7.txt
rm /tmp/CAC06037F8.txt
popd

@ Populating [[deeds_all]] is done by this shell script:


<<db-populate-deeds-all.sh>>=
<<decompress deeds files>>
<<start-sqlite>> < db-populate-deeds-all.sql
<<delete decompressed deeds files>>
@ The commands to sqlite3 needs to be in a file separate from the shell
script file.

<<db-populate-deeds-all.sql>>=  
.echo on
<<create table deeds all>>  
.separator "\t"
.import /tmp/CAC06037F1.txt deeds_all
.import /tmp/CAC06037F2.txt deeds_all
.import /tmp/CAC06037F3.txt deeds_all
.import /tmp/CAC06037F4.txt deeds_all
.import /tmp/CAC06037F5.txt deeds_all
.import /tmp/CAC06037F6.txt deeds_all
.import /tmp/CAC06037F7.txt deeds_all
.import /tmp/CAC06037F8.txt deeds_all
.tables
SELECT count(*) from deeds_all; -- record count
@ Running the script will create the [[deeds_all]] table containing
about 16 million records.
 

@\section{Creating the Subset of [[deeds_all]] of interest}

The next step is to create table [[deeds_relevant]], a subset of the
records and columns in [[deeds_all]]. The subset of records are the
ones of interest in these experiments: deeds that reflect sales at
arms length (presumedly market prices) for one single family houses
transfered in full from one party to another. The subset of columns is
simply the feature set of interest in the models. For the deeds, those
features are WRITE ME.

Returning to selecting sales transactions for one single family
residence sold in full, several columns in [[deeds_all]] can be
combined to identify this subset. These columns are:
\begin{description}
\item[[sale_date]] the date of the sale 
\item[[sale_amount]] the amount of the sale
\item[[[document_type_code]]] the type of the transfer
\item[[[pri_cat_code]]] the primary category of the transaction
\item[[[universal_land_use_code]]] how the land is used, including the
  type of improvement (buildings) that are on the land. This is a
  feature of the parcel, not a feature of the sales transaction, but
  CoreLogic carries the value in the deeds file. Screening on this
  field reduces the size of the [[deeds_all]] subset of interest.
\item[[[transaction_type_code]]] the type of transaction
\item[[[multi_apn_count]] and [[multi_apn_flag_code]]] number of
  parcels covered by the deed, including the possibility of fractional
  parcels
\end{description}

How these fields were handled is discussed for each in turn before
describing how the subset was created. Some exploratory data analysis
was needed to figure out how the fields were populated. That requires
a script and set of commands.

Below is the shell script that runs the commands in the SQL input
file. This file is built up in the narrative.
<<db-analyze-deeds-all.sh>>=
<<start-sqlite>> < db-analyze-deeds-all.sql
@ 
<<db-analyze-deeds-all.sql>>=
.echo on
.tables

@ \subsection{[[sale_date]]}
To determine how often the date of the sale is missing, I can these
SQL commands.

<<db-analyze-deeds-all.sql>>=
SELECT count(*)
FROM   deeds_all
WHERE  sale_date != '';
@ I found that the sale date is missing from about 1.1 million deeds.
It is possible to use the recording date as a proxy for the sale date,
but that wasn't done in these experiments.

The SQL clause to screen based on the sale date is
<<sale date present>>=
(sale_date != '')

@  \subsection{[[sale_amount]]}
I'm interested in arms-length transactions and these would not have a
zero price except in highly unusualy circumstance. Do determine how
often a zero price is present, I can these SQL commands:

<<db-analyze-deeds-all.sql>>=
SELECT count(*)
FROM   deeds_all
WHERE  sale_amount = 0;

@  I found about 1.2 million records had a zero amount.

<<price at least zero>>=
(sale_amount > 0)

@ \subsection{[[document_type_code]]}
To identify sales transactions, one examines the document type code
using code table [[DEEDC]]. 

<<db-analyze-deeds-all.sql>>=
SELECT   document_type_code, count(*) 
FROM     deeds_all
GROUP BY document_type_code;

@
It has these values and record counts:
\begin{description}
\item[C] construction loan; none
\item[CD] correction deed; none
\item[F] final judgment, as in a legal proceeding; only 3
\item[G] grant deed, the sale or transfer of property from one
  individual to another. Definitely of interest; about 6.8 million
\item[L] liens, the owner has granted a security interest (an
  encumberance, possibly a mortgage) on the
  property to some other party; only 132
\item[N] notice of default, given by a mortgage servicing company when
  the mortgage has not been paid for a certain amount of time; about
  1.0 million
\item[Q] quit claim, the owner terminates (quits) her interest in the
  property and transfers it to another person, often used to transfer
  property among family members or as a result of a divorce or as a
  result of a public auction designed to collect a tax debt; about 1.7
  million
\item[R] release, removing a previous claim; about 0.1 million
\item[S] loan assignment, used by mortgage investors to transfer the
  loans from one to another; none
\item[T] deed of trust, used in California by mortgage lenders to
  secure mortgage loans according to
  http://homeguides.sfgate.com/assignment-deed-trust-definition-6750.html
  (accessed 2012-11-09); about 5.8 million
\item[U] foreclosure; about 0.4 million
\item[X] multi-county deed or open-end mortgage; an open-end mortgage
  allows the borrower to increase the size of the loan under certain
  conditions; about 0.05 million
\item[Z] nominal, perhaps a deed in which the transfer price is not
  the full value of the property; for example, ``selling'' a property
  for \$10 in a transfer between a parent and child; about 0.2 million
\item[miscoded] 1 record
\end{description}

Of all these document type codes, I used only those for grant deeds
or trust deeds, about 12.2 million.

<<grant or trust deed>>=
(document_type_code = 'G' or document_type_code = 'T')
@

\subsection{[[pri_cat_code]]} 
To identify arms-length sales transactions, I examined the
[[pri_cat_code]] field which has code table [[PRICATCODE]] containing
these values and counts for the deeds of interest:

<<db-analyze-deeds-all.sql>>=
SELECT   pri_cat_code, count(*)
FROM     deeds_all
GROUP BY pri_cat_code;

@ It has these values and record counts: 
\begin{description}
\item[A] arms-length transaction; about 4.7 million
\item[B] non-arms-length transaction for a purchase; about 3.7 million 
\item[C] non-arms-length transaction, not a purchase (example: a
  foreclosure); about 0.8 million
\item[D] non-purchase, about 5.8 million (possibly many of these are
  mortgage-related)
\item[E] timeshare; about 400
\item[F] notice of default; a mortgage has not been paid for several
  months, about 1.1 million
\item[G] assignment; none
\item[H] release; none
\end{description}

Of these, the only type of interest is arms-length transactions.

<<arms-length sale>>=
(pri_cat_code = 'A')
@
\subsection{[[universal_land_use_code]]} 
To identify sales of single family residences, the
[[universal_land_use_code]] is used. 

<<db-analyze-deeds-all.sql>>=
SELECT   universal_land_use_code, count(*)
FROM     deeds_all
GROUP BY universal_land_use_code;

@ It has code table [[LUSEI]] with many values. Selected code values are:
\begin{description}
\item[100] residential not otherwise classified
\item[102] townhouse or row house
\item[103] apartment or hotel
\item[106] apartment
\item[109] cabin
\item[111] cooperative
\item[112] condominium
\item[...] 
\item[127] hotel
\item[130] resort hotel
\item[131] multi family 10 units plus
\item[132] multi family 10 unites less
\item[...]
\item[148] PUD, planned urban devlopment
\item[...]
\item[160] rural homesite
\item[163] SFR, single family residence, about 6.9 million
\item[885] well/water
\item[886] well/gas/oil
\item[899] well/gas/oil II
\item[999] type unknown
\end{description}

I excluded from the list the huge number of commercial property
types. For this work, we want only the single family residences, of
which there are about 5.8 million associated with grant and trust
deeds. There are about 4.3 million parcels with a empty string as
their classification.

<<single-family residence>>=
(universal_land_use_code = '163')

@ \subsection{[[transaction_type_code]]}
Some of the deeds are not for sales and the type of sale is recorded
in the [[transaction_type_code]] field which has code table [[TRNTP]].

<<db-analyze-deeds-all.sql>>=
SELECT   transaction_type_code, count(*)
FROM     deeds_all
GROUP BY transaction_type_code;

@ 
Below are the codes and record counts. Note that the record layout
from CoreLogic says there are three positions for the code, but there is
only one position.
\begin{description}
\item[1] resale of existing property, about 5.0 million.
\item[2] refinance of the property, about 5.8 million
\item[3] subdivision or new construction; the parcel was sold with a
  house on it for the first time, about 0.1 million
\item[4] timeshare, a few hundred
\item[6] construction loan, about 0.06 million
\item[7] seller carryback, in which the seller provides the
  mortgage, about 0.1 million
\item[9] nominal, presumedly the price does not reflect the value,
  about 3.9 million, a surprisingly large number to me
\item[NULL] about 1.1 million
\item[other values] a few
\end{description}

For this modeling exercise, I am interested only in resales of
existing property (001) and first-time sales (003).

<<resale or new construction>>=
(transaction_type_code = '1' or
 transaction_type_code = '3')

@ \subsection{[[multi_apn_count]] and [[multi_apn_flag_code]]} To
identify deeds involving all of a single parcel, one could examine
some combination of these columns:
\begin{itemize}
\item [[multi_apn_count]], defined to be the number of parcels associated
with the sale
\item [[multi_apn_flag_code]], defined to indicate whether
more than one parcel was associated with the sale
\item [[ownership_transfer_percentage]], defined to be the percent of
  ownership transfered
\end{itemize}

To explore [[multi_apn_count]], I ran the SQL command below.

<<db-analyze-deeds-all.sql>>=
SELECT   multi_apn_count, count(*) 
FROM     deeds_all 
GROUP BY multi_apn_count;

@ I found that [[multi_apn_count]] content does not follow its
definition, as most often (about 16.1 million times) it is zero. It
has value one exactly 1 time. Less than 100 transactions are coded as
being for multiple APNs.

To explore [[multi_apn_flag_code]], I ran the SQL command below.

<<db-analyze-deeds-all.sql>>=
SELECT   multi_apn_flag_code, count(*)
FROM     deeds_all
GROUP BY multi_apn_flag_code;

@ [[multi_apn_flag_code]] follows the [[SLMLT]] code table. It has
these values and record counts:
\begin{description}
\item[D] multi or detail parcel sale, 0.2 million
\item[M] multiple parcel sale, 0.5 million
\item[S] split parcel sale, 0.02 million
\item[X] multi county or split parcel sale, about 3,000
\item[empty string] 15.4 million
\end{description}

TO explore [[ownership_transfer_percentage]], I ran the SQL command
below.

<<db-analyze-deeds-all.sql>>=
SELECT  ownership_transfer_percentage, count(*)
FROM    deeds_all
GROUP BY ownership_transfer_percentage;

@ I found that [[ownership_transfer_percentage]] is zero in all but 1
record.

I decided to classify as the sale of a single parcel in its entirety
as those deeds with a NULL [[multi_apn_flag_code]] and no more than 1
[[multi_apn_count]] and a zero value for
[[ownership_transfer_percentage]]. There is a detail: the
[[multi_apn_count]] and [[ownership_transfer_percentage]] fields are
TEXT fields, not INTEGER fields, so one needs to test using strings
(so that [[multi_apn_count <= 1]], which as accepted by SQlite3
without an error, will fail).

<<all of one apn>>=
(multi_apn_flag_code = '') and
(multi_apn_count = '0000' or multi_apn_count = '0001') and
(ownership_transfer_percentage = '000')

@ 

\subsection{Creating [[deeds_relevant]]}

The goal of this section is to create table [[deeds_relevant]] to
contain only deeds for arms length sales of one single family house
transfered in full from one party to another can be found by $and$-ing
all the conditions and only columns that are potentially relevant in
subsequent work.

The potentially relevant columns are those that identify the deed,
record the price of the transaction, contain features that may be
useful in estimating prices, and fields that could be used to join
deeds with the other input files.

To create table [[deeds_relevant]], I ran:

<<db-populate-deeds-relevant.sql>>=
.echo on
DROP TABLE IF EXISTS deeds_relevant;
CREATE TABLE deeds_relevant 
AS 
SELECT 
  /* key information */
  apn_unformatted,
  apn_formatted,
  apn_sequence_number,

  /* prices and dates */
  sale_amount,
  sale_date,
  recording_date,

  /* other features of the sale that vary by observation */
  document_type_code,    /* 'G' ==> Grant, 'T' ==> Trust */
  transaction_type_code  /* '1' ==> resale, '3' ==> new construction */
  
 FROM deeds_all
 WHERE <<sale date present>>
 AND   <<price at least zero>>
 AND   <<grant or trust deed>>
 AND   <<arms-length sale>>
 AND   <<single-family residence>>
 AND   <<resale or new construction>>
 AND   <<all of one apn>>
;
-- investigate why no trust deeds in deeds_relevant

SELECT COUNT(*) FROM deeds_relevant;
SELECT document_type_code, count(*)
FROM   deeds_relevant;

SELECT COUNT(*) FROM deeds_relevant;
SELECT document_type_code, count(*)
WHERE  <<sale date present>>
FROM   deeds_relevant;

SELECT COUNT(*) FROM deeds_relevant;
SELECT document_type_code, count(*)
WHERE  <<price at least zero>>
FROM   deeds_relevant;

SELECT COUNT(*) FROM deeds_relevant;
SELECT document_type_code, count(*)
WHERE  <<arms-length sale>>
FROM   deeds_relevant;

SELECT COUNT(*) FROM deeds_relevant;
SELECT document_type_code, count(*)
WHERE  <<single-family residence>>
FROM   deeds_relevant;

SELECT COUNT(*) FROM deeds_relevant;
SELECT document_type_code, count(*)
WHERE  <<all of one apn>>
FROM   deeds_relevant;



@ The script to run the command is

<<db-populate-deeds-relevant.sh>>=
<<start-sqlite>> < db-populate-deeds-relevant.sql

@ Running the script creates about 0.9 million deeds in table
[[deeds_relevant]]. Surprisingly there are no trust deeds in the
relevant deeds table. An analysis shows that less than 300 of the trust deeds
have a zero sale amount, less than 20 are identified as an arms-length
transaction, and less than 600 were resales of property or new constuction
first-time sales. The intersection of the selected deeds happens to
have no trust deeds.

\section{Importing the Taxroll}

The [[taxroll_all]] table will hold all the data from the taxroll
files. Table [[taxroll_relevant]] will hold the taxroll records
relevant to these experiments.

The taxroll file contains both an unformatted APNs and a formatted
APN, either of which could serve as the primary key for the table, if
it were always present. But neither is always present, so in implicit
primary key is generated by SQLite3. A common key field is needed to
join the deeds and taxroll data. How this is done is described as part
of the joining process.

The SQL command to create the table is just below. Column definitions
commented our are defined in the CoreLogic documentation (where the
table is called ``2580'') and not
present in the files provided.

<<create-table-taxroll-all>>=
DROP TABLE IF EXISTS taxroll_all;
CREATE TABLE taxroll_all (
  /* primary key is rowid, generated by SQLite3 */

  /* key information */

  fips_code             TEXT,
  fips_sub_code         TEXT,
  apn_unformatted       TEXT,
  apn_sequence_number   TEXT,

  /* parcel identification information */
  apn_formatted         TEXT,
  --original_apn        TEXT,
  --account_number      TEXT,

  /* parcel information */

  map_reference_1                TEXT,
  map_reference_2                TEXT,
  census_tract                   INTEGER, 
  census_block_group             TEXT,
  census_block                   TEXT,
  census_block_suffix            TEXT,
  zoning                         TEXT,
  block_number                   TEXT,
  lot_number                     TEXT,
  range                          TEXT,
  township                       TEXT,
  section                        TEXT,
  quarter_section                TEXT,
  thomas_bros_map_number         TEXT,
  flood_zone_community_panel_id  TEXT,
  --latitude                     FLOAT,
  --longitude                    FLOAT,
  centroid_code                  TEXT,
  homestead_exempt               TEXT,
  absentee_indicator_code        TEXT /* code table ABSIND */,
  tax_code_area                  TEXT,
  universal_land_use_code        TEXT /* code table LUSEI */,
  county_land_use_1              TEXT,
  county_land_use_2              TEXT,
  property_indicator_code        TEXT /* code table PROPIN */,
  municipality_name              TEXT,
  view                           TEXT /* code table VIEW */,
  location_influence_code        TEXT /* code table LOCIN */,
  number_of_buildings            TEXT,

  /* subdivision information */

  subdivision_tract_number       TEXT,
  subdivision_plat_book          TEXT,
  subdivision_plat_page          TEXT,
  subdivision_name               TEXT,

  /* property address information */

  property_address_indicator_code   TEXT /* code table ADDRIND */,
  property_house_number_prefix      TEXT,
  property_house_number             TEXT,
  property_house_number_suffix      TEXT,
  property_direction                TEXT,
  property_street_name              TEXT,
  property_mode                     TEXT,
  property_quadrant                 TEXT,
  property_apartment_unit_number    TEXT,
  property_city                     TEXT,
  property_state                    TEXT,
  property_zip_code                 TEXT,
  property_carrier_route            TEXT,
  property_match_code               TEXT /* code table MATCH */,

  /* owner information */

  owner_corporate_indicator_flag    TEXT,
  --owner_name                      TEXT,
  --owner_name_2                    TEXT,
  --owner_name_paren_1              TEXT,
  --owner_name_parent_2             TEXT,
  --owner_phone                     TEXT,
  --owner_phone_opt_out_flag        TEXT,
  --owner_etal_indicator_code       TEXT /* code table ETAL */,
  --owner_ownership_rights_code     TEXT /* code table OWNSH */,
  --owner_relationship_type_coe     TEXT /* code table RELAT */,

  /* owner mail address information */

  mail_house_number_prefix        TEXT,
  mail_house_number               TEXT,
  mail_house_number_suffix        TEXT,
  mail_direction                  TEXT,
  mail_street_name                TEXT,
  mail_mode                       TEXT,
  mail_quadrant                   TEXT,
  mail_apartment_unit_number      TEXT,
  mail_city                       TEXT,
  mail_state                      TEXT,
  mail_zip_code                   TEXT,
  mail_carrier_route              TEXT,
  mail_match_code                 TEXT /* code table MATCH */,
  mail_opt_out_flag               TEXT,

  /* values information */

  total_value_calculated                       INTEGER /* land + improvement */,
  land_value_calculated                        INTEGER,
  improvement_value_calculated                 INTEGER,
  total_value_calculated_indicator_flag        TEXT /* code table VALTY */,
  land_value_calculated_indicator_flag         TEXT /* code table VALTY */,
  improvement_value_calculated_indicator_flag  TEXT /* code table VALTY */,
  assd_total_value                             INTEGER,
  assd_land_value                              INTEGER,
  assd_improvement_value                       INTEGER,
  mkt_total_value                              INTEGER,
  mkt_land_value                               INTEGER,
  mkt_improvement_value                        INTEGER,
  appr_total_value                             INTEGER,
  appr_land_value                              INTEGER,
  appr_improvement_value                       INTEGER,
  tax_amount                                   INTEGER,
  tax_year                                     TEXT,

  /* current sale information */

  batch_id                          TEXT,
  batch_seq                         TEXT,
  document_year                     TEXT,
  --document_number                 TEXT,
  --book_page                       TEXT,
  sales_document_type_code          TEXT /* code table DEEDC */,
  recording_date                    TEXT,
  sale_date                         TEXT,
  sale_amount                       INTEGER,
  sale_code                         TEXT /* code table SCODE */,
  --seller_name                     TEXT,
  sales_transaction_type_code       TEXT /* code table TRNTP */,
  multi_apn_flag_code               TEXT /* code table SLMLT */,
  multi_apn_code                    TEXT,
  --title_company_code              TEXT,
  --title_company_name              TEXT,
  residential_model_indicator_flag  TEXT,

  /* current trust deed information */

  first_mortgage_amount                 INTEGER,
  first_mortgage_date                   TEXT,
  first_mortgage_loan_type_code         TEXT /* code table MTGTP */,
  first_mortgage_deed_type_code         TEXT /* code table DOCTY */,
  first_mortgage_term_code              TEXT /* code table MTGTC */,
  first_mortgage_term                   TEXT,
  first_mortgage_due_date               TEXT,
  first_mortgage_assumption_amount      INTEGER,
  --first_mortgage_lender_company_code  TEXT,
  --first_mortgage_lender_name          TEXT,
  second_mortgage_amount                INTEGER,
  second_mortgage_loan_type_code        TEXT /* code table MTGTP */,
  second_mortgage_deed_type_code        TEXT /* code table DOCTY */,

  /* prior sale information */

  prior_sale_transaction_id           TEXT,
  prior_sale_document_year            TEXT,
  prior_sale_document_number          TEXT,
  prior_sale_book_page                TEXT,
  prior_sale_document_type_code       TEXT /* code table DEEDC */,
  prior_sale_recording_date           TEXT,
  prior_sale_date                     TEXT,
  prior_sale_amount                   INTEGER,
  prior_sale_code                     TEXT /* code table SLMLT */,
  prior_sale_transaction_type_code    TEXT /* code table TRNTP */,
  prior_sale_multi_apn_flag_code      TEXT /* code table SLMLT */,
  prior_sale_multi_apn_count          TEXT,
  prior_sale_mortgage_amount          INTEGER,
  prior_sale_deed_type_code           TEXT /* code table DOCTY */,

  /* lot/land information */

  front_footage                       TEXT,
  depth_footage                       TEXT,
  acres                               INTEGER /* coded 9999(.)9999 */,
  land_square_footage                 INTEGER,
  lot_area                            TEXT  /* textual description */,
  
  /* square footage information */

  universal_building_square_feet                 INTEGER,
  universal_building_square_feet_indicator_code  TEXT /* code table BLDSF */,
  building_square_feet                           INTEGER,
  living_square_feet                             INTEGER,
  ground_floor_square_feet                       INTEGER,
  gross_square_feet                              INTEGER,
  adjusted_gross_square_feet                     INTEGER,
  basement_square_feet                           INTEGER,
  garage_parking_square_feet                     INTEGER,

  /* building information */

  year_built                  TEXT,
  effective_year_built        TEXT,
  bedrooms                    TEXT,
  total_rooms                 TEXT,
  total_baths_calculated      TEXT /* encoded 999(.)99 */,
  total_baths                 TEXT /* encoded 999(.)99 */,
  full_baths                  TEXT,
  half_baths                  TEXT,
  one_quarter_baths           TEXT,
  three_quarter_baths         TEXT,
  bath_fixtures               TEXT,
  air_conditioning_code       TEXT /* code table AC */,
  basement_finish_code        TEXT /* code table BSMTF */,
  bldg_code                   TEXT /* code table BLDG */,
  bldg_improvement_code       TEXT /* code table IMPRV */,
  condition_code              TEXT /* code table COND */,
  construction_type_code      TEXT /* code table CNSTR */,
  exterior_walls_code         TEXT /* code table EXTNW */,
  fireplace_indicator_flag    TEXT /* "Y" if fireplace in building */,
  fireplace_number            TEXT,
  fireplace_type_code         TEXT /* code table FIREP */,
  foundation_code             TEXT /* code table FOUND */,
  floor_code                  TEXT /* code table FLTYP */,
  frame_code                  TEXT /* code table RFFRM */,
  garage_code                 TEXT /* code table GRGCD */,
  heating_code                TEXT /* code table HEAT */,
  mobile_home_indicator_flag  TEXT /* "Y" if a mobile home */,
  parking_spaces              TEXT,
  parking_type_code           TEXT /* code table PARKG */,
  pool_flag                   TEXT /* "Y if pool is present */,
  pool_code                   TEXT /* code table POOL */,
  quality_code                TEXT /* code table QUAL */,
  roof_cover_code             TEXT /* code table RFCOV */,
  roof_type_code              TEXT /* code table RFSHP */,
  stories_code                TEXT /* code table STORY */,
  stories_number              TEXT /* encoded 9(.)99 */,
  style_code                  TEXT /* code table STYLE */,
  units_number                TEXT /* number of residences */,
  electric_energy_code        TEXT /* code table ELEC */,
  fuel_code                   TEXT /* code table FUEL */,
  sewer_code                  TEXT /* code table SEWER */,
  water_code                  TEXT /* code table WATER */,

  /* legal description */

  legal_1                     TEXT,
  legal_2                     TEXT,
  legal_3                     TEXT
);

@ To populate [[taxroll_all]], create the table and then read the 8
taxroll files, inserting their content into the table. As for the
deeds, the input files arrive compressed and must be decompressed and
then the decompressed versions can be deleted.

<<decompress taxroll files>>=
pushd ../data/raw/from-laufer-2010-05-11/tax
gzip -d -f -c CAC06037F1.txt.gz | tail -n +2 > /tmp/CAC06037F1.txt
gzip -d -f -c CAC06037F2.txt.gz | tail -n +2 > /tmp/CAC06037F2.txt
gzip -d -f -c CAC06037F3.txt.gz | tail -n +2 > /tmp/CAC06037F3.txt
gzip -d -f -c CAC06037F4.txt.gz | tail -n +2 > /tmp/CAC06037F4.txt
gzip -d -f -c CAC06037F5.txt.gz | tail -n +2 > /tmp/CAC06037F5.txt
gzip -d -f -c CAC06037F6.txt.gz | tail -n +2 > /tmp/CAC06037F6.txt
gzip -d -f -c CAC06037F7.txt.gz | tail -n +2 > /tmp/CAC06037F7.txt
gzip -d -f -c CAC06037F8.txt.gz | tail -n +2 > /tmp/CAC06037F8.txt
popd
@ 
<<delete decompressed taxroll files>>=
rm /tmp/CAC06037F1.txt
rm /tmp/CAC06037F2.txt
rm /tmp/CAC06037F3.txt
rm /tmp/CAC06037F4.txt
rm /tmp/CAC06037F5.txt
rm /tmp/CAC06037F6.txt
rm /tmp/CAC06037F7.txt
rm /tmp/CAC06037F8.txt
popd

@ Populating [[taxroll_all]] is done by this shell script:


<<db-populate-taxroll-all.sh>>=
<<decompress taxroll files>>
<<start-sqlite>> < db-populate-taxroll-all.sql
<<delete decompressed taxroll files>>

@ The SQL commands are
<<db-populate-taxroll-all.sql>>=
.echo on
<<create-table-taxroll-all>>
.separator "\t"
.import /tmp/CAC06037F1.txt taxroll_all
.import /tmp/CAC06037F2.txt taxroll_all
.import /tmp/CAC06037F3.txt taxroll_all
.import /tmp/CAC06037F4.txt taxroll_all
.import /tmp/CAC06037F5.txt taxroll_all
.import /tmp/CAC06037F6.txt taxroll_all
.import /tmp/CAC06037F7.txt taxroll_all
.import /tmp/CAC06037F8.txt taxroll_all
.tables
SELECT count(*) FROM taxroll_all; -- record count

@  Running the script creates about 2.4 million taxroll records.

\subsection{Exploring the Taxroll Data} The 2.4 million taxroll
records include all types of parcels. We want to focus only on single
family residences, which can be identified by the same field used for
that purpose in the deeds, the [[univeral_land_use_code]] field.
 
<<db-explore-taxroll-all.sh>>=
<<start-sqlite>> < db-explore-taxroll-all.sql

<<db-explore-taxroll-all.sql>>=
.echo on
SELECT   universal_land_use_code, count(*)
FROM     taxroll_all
GROUP BY universal_land_use_code;

@  I found that there are about 1.4 million parcels identified as
single family residences.

The tax roll is updated periodically to include an estimate of the
market value of the parcels. Market values are converted using a
county-specific formula to assess values. Asses values are used to
generate property tax bills. What year do we have:

<<db-explore-taxroll-all.sql>>=
SELECT   tax_year, count(*)
FROM     taxroll_all
WHERE    <<single-family residence>>
GROUP BY tax_year;
@ I found that several thousand records had tax year 0000 and that all the
others have year 2008.

<<tax year 2008>>=
(tax_year = '2008')

@ There is a large number of potential features one could use. These
are grouped into various categories by the CoreLogic documentation. I
now explore each category.

\subsubsection{Exploring Values Information}

The project estimates prices of houses, but we already have an
estimate of the values of the houses in 2008. These estimates are used
by the tax assess as an input in determining assessed values.


<<db-explore-taxroll-all.sql>>=
SELECT min(mkt_total_value), 
       avg(mkt_total_value), 
       max(mkt_total_value)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(mkt_land_value), avg(mkt_land_value), max(mkt_land_value)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(mkt_improvement_value), 
       avg(mkt_improvement_value), 
       max(mkt_improvement_value)
FROM   taxroll_all
WHERE  <<single-family residence>>;
@  I found these values were all ways zero. So I tested the similar
calculated values, which are either market values or assessed values.

<<db-explore-taxroll-all.sql>>=
SELECT min(total_value_calculated), 
       avg(total_value_calculated), 
       max(total_value_calculated)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(land_value_calculated), 
      avg(land_value_calculated), 
       max(land_value_calculated)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(improvement_value_calculated), 
       avg(improvement_value_calculated), 
       max(improvement_value_calculated)
FROM   taxroll_all
WHERE  <<single-family residence>>;
@ I found that these values were populated:
\begin{itemize}
\item Total value ranges from \$0 to \$97 million, with an average of
  \$337,000.
\item Land value ranges from \$0 to \$54 million, with an average of
  \$203,000.
\item Improvement value ranges from \$0 to \$96 million, with an
  average of \$134,000.
\end{itemize}

Parcels with zero values are suspect.

<<parcel has value>>=
(not
    (total_value_calculated = 0) or
    (land_value_calculated = 0) or
    (improvement_value_calculated = 0)
)

@ 

\subsubsection{Exploring Current Sale Information and the Like}

I ignored all the current and prior sale information, as that
information is in the deeds file for all dates, not just for the most
recent transaction. I ignored the mortgage information because this
project is focused on the values, not the financing.


\subsubsection{Exploring Lot/Land Information}

The size of the lot would seem to be important. It appears twice: once
as measured by [[acres]], once measured by
[[land_square_footage]]. It's pretty stable and hard to change for
most properties.

<<db-explore-taxroll-all.sql>>=
SELECT min(acres), 
       avg(acres), 
       max(acres)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(land_square_footage), 
       avg(land_square_footage), 
       max(land_square_footage)
FROM   taxroll_all
WHERE  <<single-family residence>>;
@ I found that the values were populated:
\begin{itemize}
\item Acres ranges from 0 to 120,000 (not a typo!), with an
  average value of 0.6265.
\item Land square footage ranges from 0 to 436,000,000 with an average
  value of 15,138.
\end{itemize}

An acre has 43,560 square feet. With perfect data, one could translate
from acres to square footage and reach agreement, but that doesn't
work here. I decided to keep one of the values and arbitrarily picked
acres.


Suspect are parcels with a zero in either value.

<<parcel has land>>=
(acres != 0)

@ 
\subsubsection{Exploring Square Footage Information}

Square footage information measure the square feet inside
buildings. Most of the terms are self-explanatory, but a few
clarifications may help: ``building square feet'' means the footage in
the interior of the buiding; ``living square feet'' is for the part of
the building used for living and typically excludes garages and
porches; the ``universal'' prefix designates the measurement used for
value comparable properties for tax assessment purposes.

<<db-explore-taxroll-all.sql>>=
SELECT min(universal_building_square_feet), 
       avg(universal_building_square_feet), 
       max(universal_building_square_feet)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(building_square_feet), 
       avg(building_square_feet), 
       max(building_square_feet)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(living_square_feet), 
       avg(living_square_feet), 
       max(living_square_feet)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(ground_floor_square_feet), 
       avg(ground_floor_square_feet), 
       max(ground_floor_square_feet)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(gross_square_feet), 
       avg(gross_square_feet), 
       max(gross_square_feet)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(adjusted_gross_square_feet), 
       avg(adjusted_gross_square_feet), 
       max(adjusted_gross_square_feet)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(basement_square_feet), 
       avg(basement_square_feet), 
       max(basement_square_feet)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(garage_parking_square_feet), 
       avg(garage_parking_square_feet), 
       max(garage_parking_square_feet)
FROM   taxroll_all
WHERE  <<single-family residence>>;
@ I found these values

\begin{verbatim}
COLUMN                         MIN   AVG           MAX
universal_building_square_feet   0 1,738       354,707
building_square_feet             0 1,130     1,320,623
living_square_feet               0 1,735        57,660
ground_floor_square_feet         0     0             0
gross_square_feet                0     1.7      25,443
adjusted_gross_square_feet       0     0             0
basement_square_feet             0     7.1   1,110,101
garage_parking_square_feet       0     0.02      4,368
\end{verbatim}

I decided that the last five of these fields would not be used as
features because their averages are so low that most of the values
must be 0. The first two fields measure the same feature, but the
[[universal]] version is kept comparable for the purpose of generating
tax statements, so I dropped the second.

Suspect are parcels with no interior space.

<<has interior space>>=
((universal_building_square_feet != 0) and
 (living_square_feet != 0))

@ 


\subsubsection{Exploring Building Information}
We come to a long list of features called ``building information'' in
the file. The are in two main groups:
\begin{itemize}
\item One group is comprised of numerical information fields,
  including [[effective_year_built]], [[bedrooms]], [[bathrooms]],
  [[fireplace_number]] and similar.
\item The other group consists of codes including
  [[air_conditioning_code]] (the type of air conditioning) and
  [[water_code]] (the type of water service: public, well, cistern).
\end{itemize}

To explore the numerical building information fields, I determined
min, average, and max values.

<<db-explore-taxroll-all.sql>>=
SELECT min(year_built), 
       avg(year_built), 
       max(year_built)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(effective_year_built), 
       avg(effective_year_built), 
       max(effective_year_built)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(bedrooms), 
       avg(bedrooms), 
       max(bedrooms)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(total_rooms), 
       avg(total_rooms), 
       max(total_rooms)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(total_baths_calculated), 
       avg(total_baths_calculated), 
       max(total_baths_calculated)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(total_baths), 
       avg(total_baths), 
       max(total_baths)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(full_baths), 
       avg(full_baths), 
       max(full_baths)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(half_baths), 
       avg(half_baths), 
       max(half_baths)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(one_quarter_baths), 
       avg(one_quarter_baths), 
       max(one_quarter_baths)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(three_quarter_baths), 
       avg(three_quarter_baths), 
       max(three_quarter_baths)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(bath_fixtures), 
       avg(bath_fixtures), 
       max(bath_fixtures)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(fireplace_number), 
       avg(fireplace_number), 
       max(fireplace_number)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(parking_spaces), 
       avg(parking_spaces), 
       max(parking_spaces)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(stories_number), 
       avg(stories_number), 
       max(stories_number)
FROM   taxroll_all
WHERE  <<single-family residence>>;

SELECT min(units_number), 
       avg(units_number), 
       max(units_number)
FROM   taxroll_all
WHERE  <<single-family residence>>;
@ I found these values

\begin{verbatim}
COLUMN                  MIN    AVG   MAX
year_build                0 1948.3  2009
effective_year_built      0 1951.5  2009
bedrooms                  0    3.2    99
total_rooms               0    4.8    84
total_baths_calculated    0    2.09   99
total_baths               0    2.09   99
full_baths                0    2.09   99
half_baths                0    0       0
one_quarter_baths         0    0       0
three_quarter_baths       0    0       0
bath_fixtures             0    0       0
fireplace_number          0    0.59    9
parking_spaces            0    1.56  800
stories_number            0    0.96    6
units_number              0    0.997 843
\end{verbatim}

Some observations:
\begin{itemize}
\item Three fields appear to have been set
identically: [[totao_baths_calculated]] .. [[full_baths]].
\item Several fields appear to not be populated: [[half_baths]]
... [[bath_fixtures]].  
\item Several fields have unusually high maximum values: [[bedrooms]],
  [[total_rooms]], number of bath rooms fields, [[parking_spaces]],
  [[units_number]]. These taxroll records are probably not for single
  family houses.
\end{itemize}


I dropped the all-zero features and the two apparently redundant
features for number of bathrooms.

Suspect are single-family residences with more than one unit. These
potentially include parcels with more than one building. I excluded
them from analysis (there are less than 1,000 multiple-unit
single-family residences).

<<has one unit>>=
(units_number = '00001')

@ 
To explore the coded building information fields, I determined how
frequently each code was used.

<<db-explore-taxroll-all.sql>>=
SELECT air_conditioning_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY air_conditioning_code;

SELECT basement_finish_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY basement_finish_code;

SELECT bldg_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY bldg_code;

SELECT bldg_improvement_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY bldg_improvement_code;

SELECT condition_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY condition_code;

SELECT construction_type_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY construction_type_code;

SELECT exterior_walls_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY exterior_walls_code;

SELECT fireplace_type_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY fireplace_type_code;

SELECT foundation_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY foundation_code;

SELECT floor_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY floor_code;

SELECT frame_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY frame_code;

SELECT garage_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY garage_code;

SELECT heating_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY heating_code;

SELECT parking_type_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY parking_type_code;

SELECT pool_flag, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY pool_flag;

SELECT pool_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY pool_code;

SELECT quality_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY quality_code;

SELECT roof_cover_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY roof_cover_code;

SELECT roof_type_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY roof_type_code;

SELECT stories_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY stories_code;

SELECT style_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY style_code;

SELECT electric_energy_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY electric_energy_code;

SELECT fuel_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY fuel_code;

SELECT water_code, count(*)
FROM   taxroll_all
WHERE  <<single-family residence>>
GROUP BY water_code;

@  I will keep all the codes except those that are always missing for
single-family residences.

The [[garage_code]] field is a problem. It is supposed to be three
characters in length and ``000'' is the code for no garage. However,
that code is never in the filed. Perhaps a missing value indicates no
garage. The number of garages was higher than my expectation. This is
perhaps because a carport counts as a garage and there are about 0.8
million carports.

The [[pool_code]] features is the type of pool. It is provided about
the same number of times there is a pool, something coded in the
[[pool_flag]] field, where a ``Y'' values means there is a pool and
any other value included an empty string means there is no
pool. Missing values are represented in the input files as empty
strings.


\begin{verbatim}
code                  num missing
air_conditioning        1,044,959
basement_finish_code    1,423,616 (all)
bldg_code               1,423,616
bldg_improvement_code   1,423,616
condition_code            949,863
construction_type_code  1,178,213
exterior_walls_code       268,790
fireplace_type_code       645,412
foundation_code           275,252
floor_code              1,094,702
frame_code              1,423,610 (all but 6)
garage_code               297,939 perhaps missing means none
heating_code              184,428
parking_type_code         273,674
pool_flag               1,173,334 missing means no pool
pool_code               1,117,334 
quality_code              968,533
roof_cover_code           264,680
roof_type_code            307,455
stories_code            1,423,616
style_code                265,482
electric_energy_code    1,423,616
fuel_code               1,423,616
water_code              1,062,282
\end{verbatim}



\subsection{Creating [[taxroll_relevant]]}

This section creates table [[taxroll_relevant]] by select the
single-family residence records in table [[taxroll_all]] and columns
from it that are potentially relevant as features or in joining other
datasets. The features in [[taxroll_all]] that are not carried into
[[taxroll_relevant]] are the features that are identical for every
single-family residence observations, as these features contain no
value. Other features, even if they have many missing values, are
carried from [[taxroll_all]] to [[taxroll_relevant]]. This decision is
intended to provide maximum flexibility to downstream processes.

<<db-populate-taxroll-relevant.sh>>=
<<start-sqlite>> < db-populate-taxroll-relevant.sql

<<db-populate-taxroll-relevant.sql>>=
.echo on
DROP TABLE IF EXISTS taxroll_relevant;
CREATE TABLE taxroll_relevant
AS 
SELECT

  /* key and parcel identification information */
  /* and information to join with deeds and geocoding data */

  fips_code,
  fips_sub_code,
  apn_unformatted,
  apn_sequence_number,
  apn_formatted,
  
  /* potential features: parcel information */
  /* and information to join with census data */

  map_reference_1,
  map_reference_2,
  census_tract,
  census_block_group,
  census_block,
  census_block_suffix,
  zoning,
  block_number,
  lot_number,
  range,
  township,
  section,
  quarter_section,
  thomas_bros_map_number,
  flood_zone_community_panel_id,
  centroid_code,
  homestead_exempt,
  absentee_indicator_code        /* code table ABSIND */,
  tax_code_area,
  universal_land_use_code        /* code table LUSEI */,
  county_land_use_1,
  county_land_use_2,
  property_indicator_code        /* code table PROPIN */,
  municipality_name,
  view                           /* code table VIEW */,
  location_influence_code        /* code table LOCIN */,
  number_of_buildings,

  /* potential features: property address information */

  property_address_indicator_code   /* code table ADDRIND */,
  property_house_number_prefix,
  property_house_number,
  property_house_number_suffix,
  property_direction,
  property_street_name,
  property_mode,
  property_quadrant,
  property_apartment_unit_number,
  property_city,
  property_state,
  property_zip_code,
  property_carrier_route,
  property_match_code                /* code table MATCH */,

  /* potential features: owner information */
  owner_corporate_indicator_flag,

  /* potential feature: values information */
  total_value_calculated                        /* land + improvement */,
  land_value_calculated,
  improvement_value_calculated,
  tax_amount,
  tax_year,

  /* potential featurs: subdivision information */

  subdivision_tract_number,
  subdivision_plat_book,
  subdivision_plat_page,
  subdivision_name,

  /* potential features: lot/land information */

  front_footage,
  depth_footage,
  acres                                /* coded 9999(.)9999 */,
  --land_square_footage,
  lot_area                             /* textual description */,

  /* potential features: square footage information */

  universal_building_square_feet,
  living_square_feet,

  /* potential features: building information; construction period */

  year_built,
  effective_year_built,

  /* potential features: building information; sizes */

  bedrooms,
  total_rooms,
  total_baths                  /* encoded 999(.)99 */,
  fireplace_number,
  parking_spaces,
  stories_number,              /* encoded 9(.)99 */

  /* potential features: building information; codes */
  /* code features that were dropped because they are never present */
  /* are commented out */

  air_conditioning_code        /* code table AC */,
  --basement_finish_code       /* code table BSMTF */,
  --bldg_code                  /* code table BLDG */,
  --bldg_improvement_code      /* code table IMPRV */,
  condition_code               /* code table COND */,
  construction_type_code       /* code table CNSTR */,
  exterior_walls_code          /* code table EXTNW */,
  fireplace_indicator_flag     /* "Y" if fireplace in building */,
  fireplace_type_code          /* code table FIREP */,
  foundation_code              /* code table FOUND */,
  floor_code                   /* code table FLTYP */,
  frame_code                   /* code table RFFRM */,
  garage_code                  /* code table GRGCD */,
  heating_code                 /* code table HEAT */,
  mobile_home_indicator_flag   /* "Y" if a mobile home */,
  parking_type_code            /* code table PARKG */,
  pool_flag                    /* "Y if pool is present */,
  pool_code                    /* code table POOL */,
  quality_code                 /* code table QUAL */,
  roof_cover_code              /* code table RFCOV */,
  roof_type_code               /* code table RFSHP */,
  --stories_code               /* code table STORY */,
  style_code                   /* code table STYLE */,
  units_number                 /* number of apartments */,
  --electric_energy_code       /* code table ELEC */,
  --fuel_code                  /* code table FUEL */,
  --sewer_code                 /* code table SEWER */,
  water_code                   /* code table WATER */

FROM taxroll_all
WHERE <<single-family residence>>
AND   <<tax year 2008>>
AND   <<parcel has value>>
AND   <<parcel has land>>
AND   <<has interior space>>
AND   <<has one unit>>
;
SELECT COUNT(*) FROM taxroll_relevant;

@ Table [[taxroll_relevant]] has about 1.4 million records.








\section{Importing the Census Data}

The [[census]] table will contain all the data from the census file
for year 1999.  The primary key for the record is the column
[[geo_id2]] which contains the FIPS code (county number) concatenated
with the census tract number. Later, this field must be split so that
the census tract number can be used to join these records with the
taxroll records.

<<create-table-census>>=
DROP TABLE IF EXISTS census;

CREATE TABLE census (
  /* identification */

  geo_id        TEXT, 
  geo_id2       INTEGER PRIMARY KEY,     -- fips code + census tract number
  geo_sumlevel  INTEGER,
  geo_name      TEXT,

  /* data on workers 16 years of age and over */

  workers_total             INTEGER,
  workers_not_work_at_home  INTEGER,

  /* travel times for workers not working at home in minutes */

  travel_less_5      INTEGER,
  travel_5_to_9      INTEGER,
  travel_10_to_14    INTEGER,
  travel_15_to_19    INTEGER,
  travel_20_to_24    INTEGER,
  travel_25_to_29    INTEGER,
  travel_30_to_34    INTEGER,
  travel_35_to_39    INTEGER,
  travel_40_to_44    INTEGER,
  travel_45_to_59    INTEGER,
  travel_60_to_89    INTEGER,
  travel_90_or_more  INTEGER,

  workers_work_at_home  INTEGER,

  /* statistics on households and families in 1999 */
  /* a household may or may not be a family */

  household_median_income            INTEGER,
  family_household_median_income     INTEGER,
  nonfamily_household_median_income  INTEGER,
  nonfamily_median_income            INTEGER,

  /* housing units and occupancy */

  owner_occupied       INTEGER,
  renter_occupied      INTEGER,
  median_number_rooms  INTEGER
);
@  To populate table [[census]], I ran the script below. Because some
columns have INTEGER types and the SQLite import statement reads all
the input lines, it's necessary to drop the first two lines of the
data file, as these each contain a header line.

<<db-populate-census.sh>>=
tail -n +3 ../data/raw/neighborhood-data/census.csv > /tmp/census.txt
<<start-sqlite>> < db-populate-census.sql

<<db-populate-census.sql>>=
.echo on
<<create-table-census>>
.separator "\t"
.import /tmp/census.txt census
.tables
SELECT count(*) FROM census;

@ The script loads 2054 data records into the [[census]] table.

The census table has the raw data to construct three features: average
commute time, fraction of houses that are owner occupied, and the
census tract as an stand-alone column (it's imbedded in column
[[geo_id2]]).


<<db-add-census-columns.sh>>=
<<start-sqlite>> < db-add-census-columns.sql

<<db-add-census-columns.sql>>=
.echo on
ALTER TABLE census ADD COLUMN average_commute FLOAT DEFAULT 0;
UPDATE census
SET average_commute = ((travel_less_5     * ((0 + 5) / 2)) +
                       (travel_5_to_9     * ((5 + 10) / 2)) +
                       (travel_10_to_14   * ((10 + 15) / 2)) +
                       (travel_15_to_19   * ((15 + 20) / 2)) +
                       (travel_20_to_24   * ((20 + 25) / 2)) +
                       (travel_25_to_29   * ((25 + 30) / 2)) +
                       (travel_30_to_34   * ((30 + 25) / 2)) +
                       (travel_35_to_39   * ((35 + 39) / 2)) +
                       (travel_40_to_44   * ((40 + 45) / 2)) +
                       (travel_45_to_59   * ((45 + 60) / 2)) +
                       (travel_60_to_89   * ((60 + 90) / 2)) +
                       (travel_90_or_more * 120)) / 
                      workers_not_work_at_home
WHERE workers_not_work_at_home > 0;

@ In the above, the WHERE clause is needed because some census tracts
have no workers. 

Another desireable features is the fraction of houses that are
occupied by their owners.

<<db-add-census-columns.sql>>=
ALTER TABLE census ADD COLUMN fraction_owner_occupied FLOAT DEFAULT 0;
UPDATE census
SET fraction_owner_occupied = 
  owner_occupied / (1.0 * owner_occupied + renter_occupied)
WHERE (owner_occupied + renter_occupied) > 0;
@ In the above, the where clause is needed because some census tracts
have no one occupying housing.

Finally, to join the [[census]] table with the taxroll table, I will
need the census tract as a separate column.

<<db-add-census-columns.sql>>=
ALTER TABLE census ADD COLUMN census_tract INTEGER;
UPDATE census
SET census_tract = geo_id2 % 1000000;
@ 

\section{Importing the Geocoding File}

Although the deeds and taxroll file definitions from CoreLogic contain
latitude and longitude fields, those fields are not populated. Someone
working on the project long ago purchased a ``geocoding'' file that
associates APNs with latitude and longitude.

The SQL statements below will create table [[geocoding]].

<<create-geocoding>>=
DROP TABLE IF EXISTS geocoding;
CREATE TABLE geocoding (
  apn_unformatted        TEXT PRIMARY KEY,
  latitude               FLOAT,
  longitude              FLOAT
);
@ The commands are run with the script below. A complication was that
the tab-separated geocoding file has a 2 headers that should not be
imported; it is discarded with the tail command. Another complication
is that the tab-separated geocoding file has a space after the tabs,
and that confuses SQLite3's import routine. The solution is to use
[[tr]] to convert the tabs to commas.

<<db-populate-geocoding.sh>>=
tail -n +2 ../data/raw/geocoding.tsv | sed 's/\t /,/g' > /tmp/geocoding.txt
<<start-sqlite>> < db-populate-geocoding.sql

<<db-populate-geocoding.sql>>=
.echo on
<<create-geocoding>>
.separator ","
.import /tmp/geocoding.txt geocoding
SELECT count(*) FROM geocoding;
@  Running this script creates about 2.4 million geocoding records.


\section{The Big Join}

We have populated the SQLite data base with about
\begin{itemize}
\item 1.2 million relevant deeds (for entire arms-length transactions
  on single-family houses), containing an unformatted APN field
\item 1.4 million relevant taxroll records (for single family houses),
  containing an unformatted APN field and a census tract field
\item 2,000 census tract records, containing a census tract field
  stored as an INTEGER
\item 2.4 million geocoding records, containing an unformatted APN field
\end{itemize}

All that needs to be done is to join the four tables to form table
[[observations]].

Here is the script:


<<db-join.sh>>=
<<start-sqlite>> < db-join.sql

@  Here are the SQL commands to join the tables.

One might suppose that the concatenation of the APN and sale date
would form a unique primary key, but its possible for a parcel to sell
twice in the same day. 

The VACUUM command reclaims free space in the database.

<<db-join.sql>>=
.echo on
--VACUUM;

DROP TABLE IF EXISTS observations;

CREATE TABLE observations
AS 
SELECT 
/* primary key is the implicit field rowid */

/* key information (but may not be unique) */
deeds_relevant.apn_unformatted AS deeds_apn_unformatted,
deeds_relevant.sale_date,          

/* further deed identification */
deeds_relevant.apn_formatted,
deeds_relevant.apn_sequence_number AS deed_apn_sequence_number,

/* further deeds features */

deeds_relevant.sale_amount,
deeds_relevant.recording_date,
deeds_relevant.document_type_code,
deeds_relevant.transaction_type_code,

/* taxroll features: parcel identification */
taxroll_relevant.apn_formatted AS taxroll_apn_unformatted,
taxroll_relevant.apn_sequence_number AS taxroll_apn_sequence_number,

/* taxroll features : parcel information */

taxroll_relevant.map_reference_1,
taxroll_relevant.map_reference_2,

taxroll_relevant.census_tract,
taxroll_relevant.census_block_group,
taxroll_relevant.census_block,
taxroll_relevant.census_block_suffix,

taxroll_relevant.zoning,
taxroll_relevant.township,
taxroll_relevant.section,

taxroll_relevant.thomas_bros_map_number,

taxroll_relevant.flood_zone_community_panel_id,
taxroll_relevant.centroid_code,

taxroll_relevant.homestead_exempt,
taxroll_relevant.absentee_indicator_code,

taxroll_relevant.tax_code_area,
taxroll_relevant.county_land_use_1,
taxroll_relevant.county_land_use_2,
taxroll_relevant.property_indicator_code,
taxroll_relevant.municipality_name,

taxroll_relevant.view,
taxroll_relevant.location_influence_code,
taxroll_relevant.number_of_buildings,

/* --taxroll features: property address information */
/* don't carry property address features such as building number */

taxroll_relevant.property_city,
taxroll_relevant.property_state,
taxroll_relevant.property_zip_code,
taxroll_relevant.property_carrier_route,
taxroll_relevant.property_match_code,

/* potential features: owner information */

taxroll_relevant.owner_corporate_indicator_flag,

/* potential feature: values information */

taxroll_relevant.total_value_calculated,
taxroll_relevant.land_value_calculated,
taxroll_relevant.improvement_value_calculated,
taxroll_relevant.tax_amount,
taxroll_relevant.tax_year,

/* potential featurs: subdivision information */

taxroll_relevant.subdivision_tract_number,
taxroll_relevant.subdivision_plat_book,
taxroll_relevant.subdivision_plat_page,
taxroll_relevant.subdivision_name,

/* potential features: lot/land information */

taxroll_relevant.front_footage,
taxroll_relevant.depth_footage,
taxroll_relevant.acres                   /* coded 9999(.)9999 */,
taxroll_relevant.lot_area,               /* textual description */

/* potential features: square footage information */

taxroll_relevant.universal_building_square_feet,
taxroll_relevant.living_square_feet,

/* potential features: construction period */

taxroll_relevant.year_built,
taxroll_relevant.effective_year_built,

/* --taxroll features: building information: sizes */
taxroll_relevant.bedrooms,
taxroll_relevant.total_rooms,
taxroll_relevant.total_baths                  /* encoded 999(.)99 */,
taxroll_relevant.fireplace_number,
taxroll_relevant.parking_spaces,
taxroll_relevant.stories_number               /* encoded 9(.)99 */,

/* --taxroll features: building information: codes */

taxroll_relevant.air_conditioning_code,
taxroll_relevant.condition_code,
taxroll_relevant.construction_type_code,
taxroll_relevant.exterior_walls_code,
taxroll_relevant.fireplace_indicator_flag    /* "Y" if fireplace in building */,
taxroll_relevant.fireplace_type_code,
taxroll_relevant.foundation_code,
taxroll_relevant.floor_code,
taxroll_relevant.frame_code,
taxroll_relevant.garage_code,
taxroll_relevant.heating_code,
taxroll_relevant.mobile_home_indicator_flag   /* "Y" if a mobile home */,
taxroll_relevant.parking_type_code,
taxroll_relevant.pool_flag                    /* "Y if pool is present */,
taxroll_relevant.pool_code,
taxroll_relevant.quality_code,
taxroll_relevant.roof_cover_code,
taxroll_relevant.roof_type_code,
taxroll_relevant.style_code,
taxroll_relevant.units_number                 /* number of apartments */,
taxroll_relevant.water_code,

/* geocoding features */
geocoding.latitude,
geocoding.longitude,

/* census features */
census.average_commute,
census.fraction_owner_occupied,
census.household_median_income

FROM deeds_relevant
INNER JOIN taxroll_relevant 
ON   deeds_relevant.apn_unformatted = taxroll_relevant.apn_unformatted
INNER JOIN geocoding
ON         deeds_relevant.apn_unformatted = geocoding.apn_unformatted
INNER JOIN census
ON         taxroll_relevant.census_tract = census.census_tract
;

SELECT COUNT(*) FROM observations;
@ Running the command genearates about 0.9 million records in
[[observations]].

@ The final step is to free the all the tables except for the
[[observations]] table.

<<db-free.sh>>=
<<start-sqlite>> < db-free.sql
@  The VACUUM commands defragments space in the file system and then
returns it to the file system.

<<db-free.sql>>=
.echo on
DROP TABLE IF EXISTS census;
DROP TABLE IF EXISTS deeds_all;
DROP TABLE IF EXISTS deeds_relevant;
DROP TABLE IF EXISTS geocoding;
DROP TABLE IF EXISTS taxroll_all;
DROP TABLE IF EXISTS taxroll_relevant;

VACUUM;

-- db size is page_count * page_size
PRAGMA page_count;
PRAGMA page_size;

@  On my development system, the size of the database (containing only
the observation table) is about $450 \times 10^6$ bytes .






